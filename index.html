<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Engine Cycle Simulator (0‑D) — Valve Timing & Lift</title>
  <style>
    :root{ --bg:#0f1220; --panel:#161a2e; --ink:#e7eaf6; --muted:#b7bfdc; --accent:#5ee1a9; --accent2:#6ea8ff; --accent3:#ffb86b; --accent4:#ff6e7f; --grid:#2a2f4a; --radius:14px; }
    *{box-sizing:border-box}
    body{ margin:0; font:500 15px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter; color:var(--ink); background:#0f1220; }
    header{ padding:16px; text-align:center }
    header h1{ margin:0 0 6px; font-size: clamp(20px,2.4vw,28px) }
    header p{ margin:0; color:var(--muted); font-size:14px }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:16px; grid-template-columns:360px 1fr }
    @media (max-width:980px){ .wrap{ grid-template-columns:1fr } }
    .card{ background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)) , var(--panel); border:1px solid #222642; border-radius:var(--radius); }
    .controls{ padding:14px; display:grid; gap:14px }
    .controls h2{ margin:0; font-size:16px }
    .grid2{ display:grid; gap:10px; grid-template-columns:1fr 1fr }
    label{ color:var(--muted); font-size:13px }
    input[type=range]{ width:100%; -webkit-appearance:none; height:8px; border-radius:999px; background:#232847; outline:none }
    button{ appearance:none; border:0; border-radius:12px; padding:10px 12px; cursor:pointer; font-weight:700; color:#0f1220; background:linear-gradient(180deg,#9bfbc2,#5ee1a9) }
    button.secondary{ background:linear-gradient(180deg,#cce0ff,#6ea8ff); color:#081226 }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .viz{ padding:14px }
    svg{ display:block; width:100%; height:420px; background:#0c1024; border:1px solid #222642; border-radius:10px }
    .grid{ stroke:#2a2f4a; stroke-width:1 }
    .curve{ stroke:var(--accent2); stroke-width:2; fill:none }
    .axis text{ fill:#8f97c6; font-size:12px }
    .pill{ padding:6px 8px; border-radius:999px; background:#12162b; border:1px solid #222642; color:#b7bfdc; font-size:12px }
    .row{ display:grid; grid-template-columns:1fr auto; gap:10px; align-items:center }
  </style>
</head>
<body>
  <header>
    <h1>Engine Cycle Simulator (0‑D) — Valve Timing & Lift</h1>
    <p>Adjust valve timing and lift, then simulate and see cylinder pressure over 720°.</p>
  </header>
  <div class="wrap">
    <section class="card controls">
      <h2>Inputs</h2>
      <div class="grid2">
        <div>
          <label>RPM: <span class="mono pill" id="rpmVal">3000</span></label>
          <input id="rpm" type="range" min="600" max="8000" step="100" value="3000" />
        </div>
        <div>
          <label>Equivalence ratio φ: <span class="mono pill" id="phiVal">1.0</span></label>
          <input id="phi" type="range" min="0.7" max="1.3" step="0.05" value="1.0" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Intake open (deg): <span class="mono pill" id="ivoVal">710</span></label>
          <input id="ivo" type="range" min="0" max="719" step="1" value="710" />
        </div>
        <div>
          <label>Intake close (deg): <span class="mono pill" id="ivcVal">220</span></label>
          <input id="ivc" type="range" min="0" max="719" step="1" value="220" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Exhaust open (deg): <span class="mono pill" id="evoVal">480</span></label>
          <input id="evo" type="range" min="0" max="719" step="1" value="480" />
        </div>
        <div>
          <label>Exhaust close (deg): <span class="mono pill" id="evcVal">10</span></label>
          <input id="evc" type="range" min="0" max="719" step="1" value="10" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>Intake max lift (mm): <span class="mono pill" id="iliftVal">10.0</span></label>
          <input id="ilift" type="range" min="4" max="14" step="0.5" value="10" />
        </div>
        <div>
          <label>Exhaust max lift (mm): <span class="mono pill" id="eliftVal">9.0</span></label>
          <input id="elift" type="range" min="4" max="14" step="0.5" value="9" />
        </div>
      </div>
      <div class="grid2">
        <div><button id="runBtn">▶︎ Simulate</button></div>
        <div><button id="resetBtn" class="secondary">⟲ Reset</button></div>
      </div>
      <div class="row">
        <small>IMEP [bar]:</small>
        <span class="mono pill" id="imepOut">–</span>
      </div>
      <div class="row">
        <small>Work per cycle [J]:</small>
        <span class="mono pill" id="workOut">–</span>
      </div>
    </section>

    <section class="card viz">
      <svg id="plot" viewBox="0 0 1200 420" role="img" aria-label="Pressure vs crank angle"></svg>
      <div style="display:flex;justify-content:space-between;margin-top:8px">
        <span class="pill">p [bar] vs crank angle [deg]</span>
        <span class="pill">Pure JavaScript • Mobile-friendly</span>
      </div>
    </section>

    <section class="card viz">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <h2 style="margin:0;font-size:16px">Engine Animation</h2>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="playBtn">▶︎ Play</button>
          <span class="pill mono">Angle: <span id="angleOut">0</span>°</span>
        </div>
      </div>
      <svg id="engine" viewBox="0 0 600 360" role="img" aria-label="Engine animation"></svg>
      <small class="mono" style="color:#8f97c6">Schematic: piston and valves motion; blue = intake air-fuel, orange = combustion, gray = exhaust.</small>
    </section>
  </div>

  <script>
    // UI elements
    const plot = document.getElementById('plot');
    const rpm = document.getElementById('rpm');
    const phi = document.getElementById('phi');
    const ivo = document.getElementById('ivo');
    const ivc = document.getElementById('ivc');
    const evo = document.getElementById('evo');
    const evc = document.getElementById('evc');
    const ilift = document.getElementById('ilift');
    const elift = document.getElementById('elift');

    const rpmVal = document.getElementById('rpmVal');
    const phiVal = document.getElementById('phiVal');
    const ivoVal = document.getElementById('ivoVal');
    const ivcVal = document.getElementById('ivcVal');
    const evoVal = document.getElementById('evoVal');
    const evcVal = document.getElementById('evcVal');
    const iliftVal = document.getElementById('iliftVal');
    const eliftVal = document.getElementById('eliftVal');

    const imepOut = document.getElementById('imepOut');
    const workOut = document.getElementById('workOut');

    function syncLabels(){
      rpmVal.textContent = rpm.value;
      phiVal.textContent = (+phi.value).toFixed(2);
      ivoVal.textContent = ivo.value;
      ivcVal.textContent = ivc.value;
      evoVal.textContent = evo.value;
      evcVal.textContent = evc.value;
      iliftVal.textContent = (+ilift.value).toFixed(1);
      eliftVal.textContent = (+elift.value).toFixed(1);
    }
    [rpm,phi,ivo,ivc,evo,evc,ilift,elift].forEach(el=>el.addEventListener('input', syncLabels));
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      rpm.value=3000; phi.value=1.0; ivo.value=710; ivc.value=220; evo.value=480; evc.value=10; ilift.value=10; elift.value=9; syncLabels();
    });
    syncLabels();

    // Plot helpers
    function clearSVG(){ while (plot.firstChild) plot.removeChild(plot.firstChild); }
    function line(x1,y1,x2,y2){ const el = document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke','#2a2f4a'); el.setAttribute('stroke-width','1'); plot.appendChild(el); return el; }
    function path(d){ const el = document.createElementNS('http://www.w3.org/2000/svg','path'); el.setAttribute('d',d); el.setAttribute('stroke','#6ea8ff'); el.setAttribute('fill','none'); el.setAttribute('stroke-width','2'); plot.appendChild(el); return el; }
    function text(x,y,str){ const el = document.createElementNS('http://www.w3.org/2000/svg','text'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('fill','#8f97c6'); el.setAttribute('font-size','12'); el.textContent=str; plot.appendChild(el); return el; }

    function drawGrid(){
      const W=1200,H=420; clearSVG();
      for(let deg=0;deg<=720;deg+=90){ const x=(deg/720)*W; line(x,0,x,H); text(x+4,H-6,`${deg}°`); }
      for(let p=0;p<=100;p+=10){ const y=H-(p/100)*H; line(0,y,W,y); text(4,y-4,`${p}`); }
    }

    function drawCurve(theta, pbar){
      const W=1200,H=420; let d='';
      for(let i=0;i<theta.length;i++){
        const x=(theta[i]/720)*W; const y=H-(pbar[i]/100)*H; d += (i? ' L':'M')+x.toFixed(2)+','+y.toFixed(2);
      }
      path(d);
    }

    // Physics constants
    const R_AIR = 287.0;
    const GAMMA = 1.35;
    const CP = GAMMA * R_AIR / (GAMMA - 1.0);
    const CV = CP - R_AIR;
    const DEG_TO_RAD = Math.PI / 180;

    // Engine geometry
    function makeGeometry(bore, stroke, rod, cr){
      const pistonArea = Math.PI * (bore*bore) / 4;
      const crankRadius = stroke/2;
      const clearanceV = (pistonArea*stroke) / (cr - 1.0);
      return {
        bore, stroke, rod, cr, pistonArea, crankRadius, clearanceV,
        pistonDispFromTdc(thetaDeg){
          const theta = thetaDeg * DEG_TO_RAD;
          const r = crankRadius, l = rod;
          const term = Math.max(0, l*l - (r * Math.sin(theta))**2);
          const x = r * Math.cos(theta) + Math.sqrt(term);
          const x_tdc = r + l;
          return x_tdc - x;
        },
        volume(thetaDeg){
          const s = this.pistonDispFromTdc(thetaDeg);
          return clearanceV + pistonArea * s;
        },
        volumeAnddVdtheta(thetaDeg){
          const h = 0.1;
          const v = this.volume(thetaDeg);
          const vPlus = this.volume(thetaDeg + h);
          const vMinus = this.volume(thetaDeg - h);
          const dVdtheta = (vPlus - vMinus) / (2*h);
          return [v, dVdtheta];
        },
        wallAreaEstimate(thetaDeg){
          const s = this.pistonDispFromTdc(thetaDeg);
          const linerArea = Math.PI * bore * Math.max(s, 0);
          return pistonArea + linerArea;
        }
      };
    }

    // Valve profile
    function makeValve(openDeg, closeDeg, maxLift, valveDiameter, numValves, Cd){
      function duration(){ return closeDeg >= openDeg ? (closeDeg - openDeg) : (720 - openDeg + closeDeg); }
      function phaseFraction(thetaDeg){
        const t = ((thetaDeg % 720) + 720) % 720;
        if (closeDeg >= openDeg){
          if (t < openDeg || t > closeDeg) return null;
          return (t - openDeg) / Math.max(duration(), 1e-9);
        }
        if (t < openDeg && t > closeDeg) return null;
        if (t >= openDeg) return (t - openDeg) / Math.max(duration(), 1e-9);
        return (t + (720 - openDeg)) / Math.max(duration(), 1e-9);
      }
      function lift(thetaDeg){
        const f = phaseFraction(thetaDeg);
        return f==null ? 0 : maxLift * Math.sin(Math.PI * f);
      }
      function effectiveArea(thetaDeg){
        const L = lift(thetaDeg);
        if (L <= 0) return 0;
        const circumference = Math.PI * valveDiameter;
        const geometric = circumference * L * numValves;
        return geometric * Cd; // Cd applied here only
      }
      return { duration, phaseFraction, lift, effectiveArea, Cd };
    }

    // Flow
    function criticalPressureRatio(gamma){ return Math.pow(2/(gamma+1), gamma/(gamma-1)); }
    function orificeMassFlow(area, cd, p_up, t_up, p_down, gamma=GAMMA, R=R_AIR){
      if (area<=0 || p_up<=1) return 0;
      const pr = Math.max(p_down/Math.max(p_up,1e-9), 1e-9);
      const coef = cd * area * p_up * Math.sqrt(gamma/(R*Math.max(t_up,1e-9)));
      if (pr <= criticalPressureRatio(gamma)){
        return coef * Math.pow(2/(gamma+1), (gamma+1)/(2*(gamma-1)));
      }
      return coef * Math.pow(pr, 1/gamma) * Math.sqrt((2*gamma/(gamma-1))*(1 - Math.pow(pr, (gamma-1)/gamma)));
    }

    function trapz(y,x){ let s=0; for(let i=1;i<x.length;i++){ const dx=x[i]-x[i-1]; s += 0.5*(y[i]+y[i-1])*dx; } return s; }

    function runEngine({rpm, phi, ivo, ivc, evo, evc, ilift, elift}){
      const geom = makeGeometry(0.086,0.086,0.143,10.5);
      const intake = makeValve(ivo, ivc, ilift, 0.034, 2, 0.7);
      const exhaust = makeValve(evo, evc, elift, 0.029, 2, 0.7);
      const wiebe = { startDeg: 355.0, durationDeg: 40.0, a:6.0, m:2.0,
        dxb_dtheta(theta){
          if (theta<this.startDeg || theta>this.startDeg+this.durationDeg) return 0;
          const x = (theta - this.startDeg) / Math.max(this.durationDeg, 1e-9);
          return this.a*(this.m+1)/Math.max(this.durationDeg,1e-9) * Math.pow(x, this.m) * Math.exp(-this.a*Math.pow(x, this.m+1));
        }
      };

      const omegaDegPerS = 6.0 * rpm;
      const totalDeg = 720*2;
      const dtheta = 1.0;

      const thetaArr=[], volArr=[], pArr=[], TArr=[];
      let mArr=[], mdotArr=[];

      const p_intake = 1.0e5, T_intake=300;
      const p_exh = 1.1e5, T_exh=700, T_wall=420;

      const V0 = geom.volume(0);
      let p= p_intake, T=T_intake;
      let m = Math.max(p*V0/(R_AIR*T), 1e-6);
      let U = m*CV*T;
      let q_total = null;

      for(let theta=0; theta<=totalDeg+1e-9; theta+=dtheta){
        const [V, dVdth] = geom.volumeAnddVdtheta(theta);
        T = Math.max(U/Math.max(m,1e-9)/CV, 1);
        p = Math.max(m*R_AIR*T/Math.max(V,1e-12), 100);

        thetaArr.push(theta); volArr.push(V); pArr.push(p); TArr.push(T); mArr.push(m);

        const Ai = intake.effectiveArea(theta%720);
        const Ae = exhaust.effectiveArea(theta%720);

        let m_in=0, m_out=0;
        if (Ai>0){
          if (p_intake>=p){ m_in += orificeMassFlow(Ai,1.0,p_intake,T_intake,p); }
          else{ m_out += orificeMassFlow(Ai,1.0,p,T,p_intake); }
        }
        if (Ae>0){
          if (p>=p_exh){ m_out += orificeMassFlow(Ae,1.0,p,T,p_exh); }
          else{ m_in += orificeMassFlow(Ae,1.0,p_exh,T_exh,p); }
        }
        const m_dot = m_in - m_out;
        mdotArr.push(m_dot);

        const theta_mod = theta % 720;
        const dxb = wiebe.dxb_dtheta(theta_mod);
        if (q_total===null && theta_mod>=wiebe.startDeg){
          const m_air = m;
          const m_fuel = (m_air/14.7)*phi;
          const LHV = 44e6;
          q_total = m_fuel * LHV;
        }
        const qdot_comb = q_total===null ? 0 : dxb * q_total * omegaDegPerS;
        const Aw = geom.wallAreaEstimate(theta_mod);
        const h = 150.0;
        const qdot_loss = h * Aw * Math.max(T - T_wall, 0);

        const h_in = CP * T_intake;
        const h_exh = CP * T;
        const dVdt = dVdth * omegaDegPerS;
        const pdotV = p * dVdt;
        const dt = dtheta / omegaDegPerS;

        const dU = (qdot_comb - qdot_loss - pdotV + h_in*m_in - h_exh*m_out) * dt;
        U = Math.max(U + dU, 1);
        m = Math.max(m + m_dot*dt, 1e-7);
      }

      const work = trapz(pArr, volArr);
      const swept = Math.PI*(0.086*0.086)/4 * 0.086;
      const imep = work / swept;
      return { theta: thetaArr, pbar: pArr.map(px=>px/1e5), imepBar: imep/1e5, work };
    }

    function runSim(){
      const result = runEngine({
        rpm: +rpm.value,
        phi: +phi.value,
        ivo: +ivo.value,
        ivc: +ivc.value,
        evo: +evo.value,
        evc: +evc.value,
        ilift: +ilift.value/1000,
        elift: +elift.value/1000,
      });
      drawGrid();
      drawCurve(result.theta, result.pbar);
      imepOut.textContent = result.imepBar.toFixed(1);
      workOut.textContent = result.work.toFixed(2);
      updateAnimDataFrom(result); // Update animation data
    }

    document.getElementById('runBtn').addEventListener('click', runSim);
  </script>

  <script>
    // Engine animation (schematic)
    const engineSVG = document.getElementById('engine');
    const angleOut = document.getElementById('angleOut');
    const playBtn = document.getElementById('playBtn');

    const anim = { playing:false, lastT:0, idx:0, theta:[], pbar:[], ivo:0, ivc:0, evo:0, evc:0 };

    function setupEngineScene(){
      while (engineSVG.firstChild) engineSVG.removeChild(engineSVG.firstChild);
      const W=600,H=360; const pad=20; const cylW=220, cylH=220;
      const cylX= (W-cylW)/2, cylY=60;

      // Cylinder outline
      const cyl = document.createElementNS('http://www.w3.org/2000/svg','rect');
      cyl.setAttribute('x', cylX); cyl.setAttribute('y', cylY);
      cyl.setAttribute('width', cylW); cyl.setAttribute('height', cylH);
      cyl.setAttribute('fill', '#0c1024'); cyl.setAttribute('stroke', '#2a2f4a');
      engineSVG.appendChild(cyl);

      // Intake port (left top)
      const intPort = document.createElementNS('http://www.w3.org/2000/svg','rect');
      intPort.setAttribute('x', cylX-70); intPort.setAttribute('y', cylY+10);
      intPort.setAttribute('width', 70); intPort.setAttribute('height', 24);
      intPort.setAttribute('fill', '#0c1024'); intPort.setAttribute('stroke', '#2a2f4a');
      engineSVG.appendChild(intPort);

      // Exhaust port (right top)
      const exhPort = document.createElementNS('http://www.w3.org/2000/svg','rect');
      exhPort.setAttribute('x', cylX+cylW); exhPort.setAttribute('y', cylY+10);
      exhPort.setAttribute('width', 70); exhPort.setAttribute('height', 24);
      exhPort.setAttribute('fill', '#0c1024'); exhPort.setAttribute('stroke', '#2a2f4a');
      engineSVG.appendChild(exhPort);

      // Valves
      const intValve = document.createElementNS('http://www.w3.org/2000/svg','circle');
      intValve.setAttribute('cx', cylX-10); intValve.setAttribute('cy', cylY+22);
      intValve.setAttribute('r', 10); intValve.setAttribute('fill', '#5ee1a9');
      intValve.setAttribute('id','intValve'); engineSVG.appendChild(intValve);

      const exhValve = document.createElementNS('http://www.w3.org/2000/svg','circle');
      exhValve.setAttribute('cx', cylX+cylW+10); exhValve.setAttribute('cy', cylY+22);
      exhValve.setAttribute('r', 10); exhValve.setAttribute('fill', '#ff6e7f');
      exhValve.setAttribute('id','exhValve'); engineSVG.appendChild(exhValve);

      // Piston
      const piston = document.createElementNS('http://www.w3.org/2000/svg','rect');
      piston.setAttribute('x', cylX+6); piston.setAttribute('y', cylY+cylH-40);
      piston.setAttribute('width', cylW-12); piston.setAttribute('height', 36);
      piston.setAttribute('rx', 6); piston.setAttribute('fill', '#1a2042'); piston.setAttribute('stroke','#2a2f4a');
      piston.setAttribute('id','piston'); engineSVG.appendChild(piston);

      // Combustion glow layer
      const glow = document.createElementNS('http://www.w3.org/2000/svg','rect');
      glow.setAttribute('x', cylX+2); glow.setAttribute('y', cylY+2);
      glow.setAttribute('width', cylW-4); glow.setAttribute('height', cylH-4);
      glow.setAttribute('fill', '#ffb86b'); glow.setAttribute('opacity','0'); glow.setAttribute('id','glow');
      engineSVG.appendChild(glow);

      // Particle groups
      const gInt = document.createElementNS('http://www.w3.org/2000/svg','g'); gInt.setAttribute('id','gInt'); engineSVG.appendChild(gInt);
      const gExh = document.createElementNS('http://www.w3.org/2000/svg','g'); gExh.setAttribute('id','gExh'); engineSVG.appendChild(gExh);
    }

    // Particle system
    const particles = { intake:[], exhaust:[] };

    function spawnParticle(kind){
      const W=600,H=360; const cylW=220, cylH=220; const cylX=(W-cylW)/2, cylY=60;
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      let x,y,vx,vy,color,r;
      if (kind==='intake'){
        x = cylX-35; y = cylY+22; vx = 1.5+Math.random(); vy = 0.5-Math.random(); color = '#5ee1a9'; r=3;
        circle.setAttribute('fill', color); circle.setAttribute('r', r);
        document.getElementById('gInt').appendChild(circle);
        particles.intake.push({el:circle, x,y,vx,vy,life:1.8});
      }else{
        x = cylX+cylW+35; y = cylY+22; vx = -1.8-Math.random(); vy = 0.5-Math.random(); color = '#9aa0aa'; r=3;
        circle.setAttribute('fill', color); circle.setAttribute('r', r);
        document.getElementById('gExh').appendChild(circle);
        particles.exhaust.push({el:circle, x,y,vx,vy,life:1.6});
      }
    }

    function stepParticles(dt){
      const adv = (list)=>{
        for (let i=list.length-1;i>=0;i--){
          const p = list[i];
          p.x += p.vx* (60*dt/1000);
          p.y += p.vy* (60*dt/1000);
          p.life -= dt/1000;
          if (p.life<=0){
            p.el.remove(); list.splice(i,1);
          }else{
            p.el.setAttribute('cx', p.x.toFixed(1));
            p.el.setAttribute('cy', p.y.toFixed(1));
            p.el.setAttribute('opacity', Math.max(0, p.life/1.8).toFixed(2));
          }
        }
      };
      adv(particles.intake); adv(particles.exhaust);
    }

    // Helpers to compute kinematics for animation
    function pistonYAtTheta(theta){
      const bore=0.086, stroke=0.086, rod=0.143; const area=Math.PI*(bore*bore)/4; const r=stroke/2, l=rod;
      const t = theta*DEG_TO_RAD; const term = Math.max(0, l*l - (r*Math.sin(t))**2);
      const x = r*Math.cos(t) + Math.sqrt(term); const x_tdc = r + l; const s = x_tdc - x; // [m]
      // Map to pixel Y inside cylinder rectangle
      const W=600,H=360; const cylW=220,cylH=220; const cylX=(W-cylW)/2, cylY=60; const maxStrokePx = cylH-40;
      const s_norm = Math.min(1, Math.max(0, s / stroke));
      return cylY + (s_norm * maxStrokePx);
    }

    function valveOffset(lift_m){
      // map lift in meters to visual pixel offset (scale mm to ~12px at 10mm)
      const lift_mm = lift_m*1000; return (lift_mm/10)*12;
    }

    function animateLoop(t){
      if (!anim.playing){ anim.lastT=0; return; }
      if (!anim.lastT) anim.lastT = t;
      const dt = t - anim.lastT; anim.lastT = t;

      // Advance index based on RPM and sampling density
      const degPerMs = (+rpm.value) * 720 / 60000;
      const dtheta = 2; // assume sampling every 2 deg for animation pacing
      const msPerStep = dtheta / Math.max(1e-6, degPerMs);
      if (dt >= msPerStep){
        anim.idx = (anim.idx + 1) % anim.theta.length;
      }

      const theta = anim.theta[anim.idx];
      angleOut.textContent = theta.toFixed(0);

      // Update piston position
      const y = pistonYAtTheta(theta);
      const piston = document.getElementById('piston');
      piston.setAttribute('y', (y-36).toFixed(1));

      // Update valves
      const intakeValve = makeValve(+ivo.value, +ivc.value, +ilift.value/1000, 0.034, 2, 0.7);
      const exhaustValve = makeValve(+evo.value, +evc.value, +elift.value/1000, 0.029, 2, 0.7);
      const intLift = intakeValve.lift(theta);
      const exhLift = exhaustValve.lift(theta);
      const intValve = document.getElementById('intValve');
      const exhValve = document.getElementById('exhValve');
      const baseY = 60+22; // cylY+22
      intValve.setAttribute('cy', (baseY + valveOffset(intLift)).toFixed(1));
      exhValve.setAttribute('cy', (baseY + valveOffset(exhLift)).toFixed(1));

      // Combustion glow using Wiebe derivative
      const wiebe = { startDeg:355, durationDeg:40, a:6, m:2, dxb(theta){ if (theta<355||theta>395) return 0; const x=(theta-355)/40; return this.a*(this.m+1)/40 * Math.pow(x,this.m)* Math.exp(-this.a*Math.pow(x,this.m+1)); } };
      const thetaMod = ((theta%720)+720)%720;
      const glow = document.getElementById('glow');
      const combi = wiebe.dxb(thetaMod);
      glow.setAttribute('opacity', Math.min(0.6, combi*8).toFixed(2));

      // Spawn intake/exhaust particles when flows are plausible
      const p_bar = anim.pbar[anim.idx];
      const p = p_bar*1e5; const p_intake=1e5, p_exh=1.1e5;
      if (intLift>1e-4 && p_intake>=p && Math.random()<0.7) spawnParticle('intake');
      if (exhLift>1e-4 && p>=p_exh && Math.random()<0.7) spawnParticle('exhaust');
      stepParticles(dt);

      requestAnimationFrame(animateLoop);
    }

    playBtn.addEventListener('click', ()=>{
      if (!anim.theta.length){
        // Require a simulation first
        runSim();
      }
      anim.playing = !anim.playing;
      playBtn.textContent = anim.playing ? '❚❚ Pause' : '▶︎ Play';
      if (anim.playing){ anim.idx=0; anim.lastT=0; requestAnimationFrame(animateLoop); }
    });

    function updateAnimDataFrom(result){
      anim.theta = result.theta; anim.pbar = result.pbar;
      setupEngineScene(); angleOut.textContent = '0';
    }
  </script>
</body>
</html>