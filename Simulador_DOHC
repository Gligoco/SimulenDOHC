<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulador de Variadores de Fase — Motor 4T DOHC</title>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2e; --ink:#e7eaf6; --muted:#b7bfdc;
    --accent:#5ee1a9; --accent2:#6ea8ff; --accent3:#ffb86b; --accent4:#ff6e7f;
    --grid:#2a2f4a; --warning:#ffd166;
    --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
    --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:500 16px/1.4 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Inter,"Helvetica Neue",Arial;
    color:var(--ink); background: radial-gradient(1200px 800px at 20% -10%,#1b2040 0%,#0f1220 45%) fixed;
  }
  header{
    padding:18px 20px 0; text-align:center;
  }
  header h1{font-size: clamp(20px, 2.6vw, 30px); margin:0 0 6px}
  header p{margin:0;color:var(--muted); font-size:14px}
  .wrap{
    padding:18px; max-width:1200px; margin:0 auto; display:grid; gap:18px;
    grid-template-columns: 360px 1fr;
  }
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)) , var(--panel);
    border:1px solid #222642; border-radius:var(--radius); box-shadow:var(--shadow);
  }
  .controls{ padding:16px; display:grid; gap:16px}
  .controls h2{margin:0 0 8px; font-size:16px; letter-spacing:.3px; color:#dfe6ff}
  .row{ display:grid; grid-template-columns:1fr auto; gap:12px; align-items:center}
  .row small{ color:var(--muted)}
  .slider{ display:grid; gap:6px }
  .slider label{ font-size:13px; color:var(--muted)}
  input[type=range]{ width:100% }
  input[type=range]{
    -webkit-appearance:none; height:8px; border-radius:999px; background:#232847; outline:none;
  }
  input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none; width:20px; height:20px; border-radius:50%;
    background:linear-gradient(180deg,#ffffff,#b8c0ff); border:2px solid #0f1220; box-shadow:0 2px 10px rgba(0,0,0,.4)
  }
  .grid2{ display:grid; gap:10px; grid-template-columns:1fr 1fr}
  button, .btn{
    appearance:none; border:0; border-radius:12px; padding:10px 12px; cursor:pointer; font-weight:700;
    color:#0f1220; background:linear-gradient(180deg,#9bfbc2,#5ee1a9); box-shadow:var(--shadow)
  }
  button.secondary{
    background:linear-gradient(180deg,#cce0ff,#6ea8ff); color:#081226
  }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .metrics{ padding:14px; border-top:1px solid #222642; display:grid; gap:10px}
  .metrics .kv{ display:grid; grid-template-columns: 1fr 1fr; gap:8px}
  .kv div{background:#12162b; padding:10px; border-radius:10px; border:1px solid #222642}
  .kv b{display:block; font-size:12px; color:var(--muted); font-weight:600}
  .kv span{font-weight:800; letter-spacing:.2px}

  /* Visualizador */
  .viz{ padding:16px }
  .legend{ display:flex; gap:12px; flex-wrap:wrap; margin-bottom:10px }
  .dot{ width:12px; height:12px; border-radius:50%}
  .legend .item{ display:flex; align-items:center; gap:6px; font-size:13px; color:var(--muted)}
  .stage{ background:#0c1024; border:1px solid #222642; border-radius:10px; overflow:hidden; position:relative }
  svg{ display:block; width:100%; height:360px; }
  .axis text{ fill:#8f97c6; font-size:12px }
  .tick line{ stroke:#2a2f4a; stroke-width:1 }
  .grid-line{ stroke:#1d2241; stroke-width:1 }
  .range-int{ fill:rgba(94,225,169,.28); stroke:var(--accent); stroke-width:2}
  .range-exh{ fill:rgba(255,110,127,.23); stroke:var(--accent4); stroke-width:2}
  .overlap{ fill:rgba(255,209,102,.28); stroke:var(--warning); stroke-dasharray:5 4; stroke-width:2 }
  .centerline{ stroke:var(--accent3); stroke-dasharray:6 6; stroke-width:2; opacity:.9 }
  .cursor{ stroke:#ffffff; stroke-width:2; opacity:.85 }
  .badge{
    position:absolute; right:10px; top:10px; background:#12162b; border:1px solid #222642;
    color:var(--muted); border-radius:10px; padding:8px 10px; font-size:12px
  }
  .toolbar{ display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:10px }
  .left, .right{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .checkbox{ display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px }
  .note{ font-size:12px; color:#92a0ff; margin-top:8px }
  .footer{ color:#7a84b9; font-size:12px; text-align:center; padding:10px 0 22px }
  .pill{ padding:6px 8px; border-radius:999px; background:#12162b; border:1px solid #222642; color:#b7bfdc; font-size:12px }
</style>
</head>
<body>
  <header>
    <h1>Simulador de Variadores de Fase — Motor 4T DOHC</h1>
    <p>Explore, ao vivo, como adiantar/atrasar os comandos de admissão e escape afeta abertura/fechamento, <em>overlap</em>, e centro dos ressaltos ao longo de 720° (duas voltas do virabrequim).</p>
  </header>

  <div class="wrap">
    <!-- CONTROLES -->
    <section class="card controls">
      <h2>Entradas</h2>

      <div class="slider">
        <label for="intPhase">Fase Admissão (° virabrequim): <span id="intPhaseVal" class="mono pill">0</span></label>
        <input id="intPhase" type="range" min="-60" max="60" step="1" value="0" />
        <small>Negativo = atrasar, Positivo = adiantar (desloca o comando de admissão inteiro).</small>
      </div>

      <div class="slider">
        <label for="exhPhase">Fase Escape (° virabrequim): <span id="exhPhaseVal" class="mono pill">0</span></label>
        <input id="exhPhase" type="range" min="-60" max="60" step="1" value="0" />
        <small>Negativo = atrasar, Positivo = adiantar (desloca o comando de escape inteiro).</small>
      </div>

      <div class="grid2">
        <div class="slider">
          <label for="rpm">Rotação (RPM): <span id="rpmVal" class="mono pill">1500</span></label>
          <input id="rpm" type="range" min="400" max="8000" step="50" value="1500" />
        </div>
        <div class="slider">
          <label for="duration">Duração nominal (°CA, 1 mm): <span id="durVal" class="mono pill">240</span></label>
          <input id="duration" type="range" min="200" max="280" step="1" value="240" />
        </div>
      </div>

      <div class="grid2">
        <button id="toggle">▶︎ Reproduzir</button>
        <button id="reset" class="secondary">⟲ Reset</button>
      </div>

      <div class="toolbar">
        <div class="left">
          <label class="checkbox"><input id="showGrid" type="checkbox" checked> Mostrar grade</label>
          <label class="checkbox"><input id="lockOverlap" type="checkbox"> Trancar overlap (move comandos em sentidos opostos)</label>
        </div>
        <div class="right">
          <button class="secondary" id="preset1">Padrão</button>
          <button class="secondary" id="preset2">Overlap Máx.</button>
          <button class="secondary" id="preset3">Cruzeiro</button>
        </div>
      </div>

      <div class="metrics">
        <div class="kv">
          <div><b>IVO / IVC (°CA)</b><span class="mono" id="ivoivc">–</span></div>
          <div><b>EVO / EVC (°CA)</b><span class="mono" id="evoevc">–</span></div>
          <div><b>Overlap (°)</b><span class="mono" id="overlapOut">–</span></div>
          <div><b>Centros (ICL / ECL)</b><span class="mono" id="centersOut">–</span></div>
        </div>
        <small class="note">Convenção de 4T: 0° = PMS de troca (entre escape↔adm), 180° = PMI, 360° = PMS (compressão), 540° = PMI, 720° = ciclo completo.</small>
      </div>
    </section>

    <!-- VISUALIZAÇÃO -->
    <section class="card viz">
      <div class="legend">
        <div class="item"><span class="dot" style="background:var(--accent)"></span> Admissão</div>
        <div class="item"><span class="dot" style="background:var(--accent4)"></span> Escape</div>
        <div class="item"><span class="dot" style="background:var(--warning)"></span> Overlap</div>
        <div class="item"><span class="dot" style="background:var(--accent3)"></span> Centros (ICL/ECL)</div>
      </div>
      <div class="stage">
        <div class="badge mono">Ângulo do virabrequim: <span id="cursorDeg">0</span>°</div>
        <svg id="svg" viewBox="0 0 1200 360" role="img" aria-label="Diagrama de eventos sobre 720 graus de virabrequim">
          <!-- eixos e grade são desenhados via JS -->
        </svg>
      </div>

      <div class="toolbar">
        <div class="left">
          <span class="pill">Dica: arraste os sliders e observe o <em>overlap</em> próximo de 0°.</span>
        </div>
        <div class="right">
          <span class="pill">Sem libs externas • HTML único</span>
        </div>
      </div>
    </section>
  </div>

  <div class="footer">
    Feito para estudo de faseamento variável em DOHC. Os valores são didáticos; não representam um comando específico de fábrica.
  </div>

<script>
/* ===========================
   Utilidades de ângulo (0–720)
   =========================== */
const WRAP = 720;
const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
const wrap = d => ((d % WRAP) + WRAP) % WRAP;

// soma com wrap em 720
const addDeg = (a,b)=>wrap(a+b);

// converte start/end para faixa "para frente" (close >= open)
function forwardRange(start, end){
  let s = wrap(start), e = wrap(end);
  if (e < s) e += WRAP;
  return [s, e];
}

// verifica se angle está na faixa start→end, considerando wrap
function inRange(angle, start, end){
  const [s,e] = forwardRange(start,end);
  let a = angle;
  if (a < s) a += WRAP;
  return a >= s && a <= e;
}

// comprimento de interseção (em graus) entre faixas (periodicidade 720)
function overlapLen(start1,end1,start2,end2){
  // normaliza para frente
  let [s1,e1] = forwardRange(start1,end1);
  let [s2,e2] = forwardRange(start2,end2);

  // checar deslocamentos de s2/e2 por -720, 0, +720 para capturar o melhor cruzamento
  let best = 0;
  [-WRAP,0,WRAP].forEach(shift=>{
    const a1=s1, b1=e1;
    const a2=s2+shift, b2=e2+shift;
    const lo = Math.max(a1, a2);
    const hi = Math.min(b1, b2);
    const len = Math.max(0, hi - lo);
    if (len > best) best = len;
  });
  return best;
}

// ponto médio ao longo da faixa (seguindo sentido crescente)
function midAngle(start, end){
  let [s,e] = forwardRange(start,end);
  return wrap( s + (e - s)/2 );
}

// converte um grau "global" em rótulo de fase (ATDC, ABDC etc.) apenas para leitura
function prettyDeg(d){
  const x = wrap(d);
  const tags = [
    {deg:0, label:'TDC'},
    {deg:180, label:'BDC'},
    {deg:360, label:'TDC'},
    {deg:540, label:'BDC'},
    {deg:720, label:'TDC'}
  ];
  // mostrar número absoluto
  return `${x.toFixed(0)}°`;
}

/* ===========================
   Modelo simplificado do comando
   =========================== */
/*
  Convenção do ciclo:
  0°   = TDC de troca (entre escape e admissão)
  180° = BDC
  360° = TDC compressão
  540° = BDC
  720° = fim do ciclo

  Base didática (sem VVT):
  - IVO = -10° (ou 710°)   (antes do TDC de troca)
  - IVC =  230°            (50° ABDC)
  - EVO =  490°            (50° BBDC)
  - EVC =   10°            (10° ATDC)
  Duração nominal inicial: 240°
*/
const base = {
  IVO: -10, IVC: 230,
  EVO: 490, EVC: 10,
  duration: 240
};

// estado mutável (UI)
const state = {
  intPhase: 0,  // graus do virabrequim (+ adianta, - atrasa)
  exhPhase: 0,
  rpm: 1500,
  duration: 240,
  running: false,
  lockOverlap: false
};

// aplica fase ao par abertura/fechamento, mantendo duração
function phasePair(open, close, phase){
  return [ addDeg(open, phase), addDeg(close, phase) ];
}

/* ===========================
   Desenho do SVG
   =========================== */
const svg = document.getElementById('svg');
const W = 1200, H = 360;
const PAD = {l:60, r:20, t:26, b:42};
const plot = { x0: PAD.l, x1: W-PAD.r, y0: PAD.t, y1: H-PAD.b };
const scaleX = deg => plot.x0 + (deg/WRAP)*(plot.x1-plot.x0);

function clearSVG(){
  while (svg.firstChild) svg.removeChild(svg.firstChild);
}

function line(x1,y1,x2,y2, cls, parent=svg){
  const el = document.createElementNS('http://www.w3.org/2000/svg','line');
  el.setAttribute('x1',x1); el.setAttribute('y1',y1);
  el.setAttribute('x2',x2); el.setAttribute('y2',y2);
  el.setAttribute('class',cls||'');
  parent.appendChild(el);
  return el;
}
function rect(x,y,w,h, cls, parent=svg){
  const el = document.createElementNS('http://www.w3.org/2000/svg','rect');
  el.setAttribute('x',x); el.setAttribute('y',y);
  el.setAttribute('width',w); el.setAttribute('height',h);
  el.setAttribute('class',cls||'');
  parent.appendChild(el);
  return el;
}
function text(x,y,str, cls, parent=svg){
  const el = document.createElementNS('http://www.w3.org/2000/svg','text');
  el.setAttribute('x',x); el.setAttribute('y',y);
  el.setAttribute('class',cls||'');
  el.textContent = str;
  parent.appendChild(el);
  return el;
}
function path(d, cls, parent=svg){
  const el = document.createElementNS('http://www.w3.org/2000/svg','path');
  el.setAttribute('d',d); el.setAttribute('class',cls||'');
  parent.appendChild(el);
  return el;
}

function drawAxes(showGrid=true){
  // fundo
  rect(0,0,W,H,'');
  // grade vertical
  const group = document.createElementNS('http://www.w3.org/2000/svg','g');
  group.setAttribute('class','axis');
  svg.appendChild(group);

  const yTop = plot.y0 + 60;
  const yMid = plot.y0 + 160;
  const yBot = plot.y1 - 40;

  // Banda onde colocaremos as barras
  const bandIntY = plot.y0 + 100;
  const bandExhY = plot.y0 + 190;

  // delimita faixa de barras
  if (showGrid){
    const gy = [bandIntY-22, bandIntY+22, bandExhY-22, bandExhY+22];
    rect(plot.x0, gy[0], plot.x1-plot.x0, 44, '', svg).setAttribute('fill','rgba(255,255,255,0.01)');
    rect(plot.x0, gy[2], plot.x1-plot.x0, 44, '', svg).setAttribute('fill','rgba(255,255,255,0.01)');
  }

  // ticks a cada 90°
  for (let deg=0; deg<=WRAP; deg+=90){
    const x = scaleX(deg);
    if (showGrid) line(x, plot.y0, x, plot.y1, 'grid-line');
    const lbl = (deg%360===0) ? 'TDC' : (deg%180===0?'BDC':'');
    const t = text(x, plot.y1+18, `${deg}° ${lbl}`, '', group);
    t.setAttribute('text-anchor', 'middle');
  }

  // rótulos das faixas
  const t1 = text(plot.x0-10, bandIntY+4, 'Admissão', '', group);
  t1.setAttribute('text-anchor','end'); t1.setAttribute('fill','#9af3c8');
  const t2 = text(plot.x0-10, bandExhY+4, 'Escape', '', group);
  t2.setAttribute('text-anchor','end'); t2.setAttribute('fill','#ff92a0');

  return {bandIntY, bandExhY};
}

function drawRange(start, end, y, cls){
  // pode haver wrap; desenhamos 1–2 retângulos
  const [s,e] = forwardRange(start,end);
  const x1 = scaleX(wrap(s)), x2a = scaleX(Math.min(WRAP, e));
  const h  = 28, yTop = y - h/2;

  // 1º segmento
  rect(x1, yTop, x2a - x1, h, cls);
  // 2º segmento se passou de 720
  if (e > WRAP){
    rect(scaleX(0), yTop, scaleX(wrap(e)) - scaleX(0), h, cls);
  }
}

function drawCenterline(angle, yFrom, yTo){
  const x = scaleX(angle);
  line(x, yFrom, x, yTo, 'centerline');
}

function drawCursor(angle){
  const x = scaleX(wrap(angle));
  line(x, plot.y0, x, plot.y1, 'cursor').setAttribute('id','cursorLine');
}

/* ===========================
   Cálculos de eventos a partir do estado
   =========================== */
function computeEvents(){
  const dur = state.duration;

  // recalcular IVC/EVO mantendo duração nominal simétrica em torno do centro
  // fazemos: IVO_base e IVC_base giram juntos mas duration pode ser alterada
  // Ajuste: manter simetria — centro permanece no meio original; mudamos abertura/fechamento igualmente
  const baseIntCenter = midAngle(base.IVO, base.IVC); // centro do ressalto (ICL)
  const baseExhCenter = midAngle(base.EVO, base.EVC); // centro do ressalto (ECL)

  const half = dur/2;

  let ICL = addDeg(baseIntCenter, state.intPhase);
  let ECL = addDeg(baseExhCenter, state.exhPhase);

  // eventos (abertura/fechamento) assumindo perfil simétrico
  let IVO = addDeg(ICL, -half);
  let IVC = addDeg(ICL,  half);
  let EVO = addDeg(ECL, -half);
  let EVC = addDeg(ECL,  half);

  // saída legível / métricas
  const ovlp = overlapLen(IVO, IVC, EVO, EVC); // total onde as duas válvulas ficam abertas

  return {IVO, IVC, EVO, EVC, ICL, ECL, overlap: ovlp};
}

/* ===========================
   Render principal
   =========================== */
function render(){
  clearSVG();
  const {bandIntY, bandExhY} = drawAxes(document.getElementById('showGrid').checked);

  const ev = computeEvents();

  // barras de admissão e escape
  drawRange(ev.IVO, ev.IVC, bandIntY, 'range-int');
  drawRange(ev.EVO, ev.EVC, bandExhY, 'range-exh');

  // centro dos ressaltos
  drawCenterline(ev.ICL, bandIntY-26, bandIntY+26);
  drawCenterline(ev.ECL, bandExhY-26, bandExhY+26);

  // overlap (interseção)
  // Para desenhar, calculamos interseções com deslocamentos -720/0/+720
  const interRects = [];
  [-WRAP,0,WRAP].forEach(shift=>{
    const [iS,iE] = forwardRange(ev.IVO, ev.IVC);
    const [eS,eE] = forwardRange(ev.EVO+shift, ev.EVC+shift);
    const lo = Math.max(iS, eS);
    const hi = Math.min(iE, eE);
    if (hi > lo){
      // desenhar no eixo 0–720
      const loW = wrap(lo), hiW = wrap(hi);
      if (hiW >= loW){
        interRects.push([loW, hiW]);
      }else{
        interRects.push([0, hiW], [loW, WRAP]);
      }
    }
  });
  interRects.forEach(([a,b])=>{
    const x = scaleX(a), w = scaleX(b)-scaleX(a), y = (bandIntY+bandExhY)/2;
    rect(x, y-14, w, 28, 'overlap');
  });

  // cursor instantâneo (animação)
  drawCursor(anim.angle);

  // Atualiza números
  document.getElementById('ivoivc').textContent = `${prettyDeg(ev.IVO)} / ${prettyDeg(ev.IVC)}`;
  document.getElementById('evoevc').textContent = `${prettyDeg(ev.EVO)} / ${prettyDeg(ev.EVC)}`;
  document.getElementById('overlapOut').textContent = `${ev.overlap.toFixed(1)}°`;
  document.getElementById('centersOut').textContent =
    `ICL ${prettyDeg(ev.ICL)}  •  ECL ${prettyDeg(ev.ECL)}`;
}

/* ===========================
   Interação / UI
   =========================== */
const elInt = document.getElementById('intPhase');
const elExh = document.getElementById('exhPhase');
const elRpm = document.getElementById('rpm');
const elDur = document.getElementById('duration');
const elIntVal = document.getElementById('intPhaseVal');
const elExhVal = document.getElementById('exhPhaseVal');
const elRpmVal = document.getElementById('rpmVal');
const elDurVal = document.getElementById('durVal');

function syncLabels(){
  elIntVal.textContent = `${state.intPhase}`;
  elExhVal.textContent = `${state.exhPhase}`;
  elRpmVal.textContent = `${state.rpm}`;
  elDurVal.textContent = `${state.duration}`;
}

function setPhase(which, val){
  val = Math.round(val);
  if (state.lockOverlap){
    // mover em sentidos opostos para manter overlap semelhante
    if (which==='int'){
      const delta = val - state.intPhase;
      state.intPhase = val;
      state.exhPhase = clamp(state.exhPhase - delta, -60, 60);
      elExh.value = state.exhPhase;
    }else{
      const delta = val - state.exhPhase;
      state.exhPhase = val;
      state.intPhase = clamp(state.intPhase - delta, -60, 60);
      elInt.value = state.intPhase;
    }
  }else{
    if (which==='int') state.intPhase = val;
    else state.exhPhase = val;
  }
  syncLabels(); render();
}

elInt.addEventListener('input', e => setPhase('int', +e.target.value));
elExh.addEventListener('input', e => setPhase('exh', +e.target.value));
elRpm.addEventListener('input', e => { state.rpm = +e.target.value; syncLabels(); });
elDur.addEventListener('input', e => { state.duration = +e.target.value; syncLabels(); render(); });

document.getElementById('showGrid').addEventListener('change', render);
document.getElementById('lockOverlap').addEventListener('change', e => { state.lockOverlap = e.target.checked; });

document.getElementById('reset').addEventListener('click', ()=>{
  state.intPhase = 0; state.exhPhase = 0; state.rpm = 1500; state.duration = base.duration;
  elInt.value=0; elExh.value=0; elRpm.value=1500; elDur.value=base.duration;
  syncLabels(); render();
});

document.getElementById('preset1').addEventListener('click', ()=>{
  state.intPhase = 0; state.exhPhase = 0; state.duration = 240;
  elInt.value=0; elExh.value=0; elDur.value=240; syncLabels(); render();
});
document.getElementById('preset2').addEventListener('click', ()=>{
  state.intPhase = +30; state.exhPhase = -30; state.duration = 250;
  elInt.value=state.intPhase; elExh.value=state.exhPhase; elDur.value=state.duration; syncLabels(); render();
});
document.getElementById('preset3').addEventListener('click', ()=>{
  state.intPhase = +10; state.exhPhase = -5; state.duration = 230;
  elInt.value=state.intPhase; elExh.value=state.exhPhase; elDur.value=state.duration; syncLabels(); render();
});

/* ===========================
   Animação do virabrequim
   =========================== */
const anim = { angle: 0, lastT: 0, raf: null };
const cursorDeg = document.getElementById('cursorDeg');

function loop(t){
  if (!state.running){ anim.raf = null; return; }
  if (!anim.lastT) anim.lastT = t;
  const dt = t - anim.lastT; // ms
  anim.lastT = t;

  // deg por ms: rpm * 720 deg / 60.000 ms
  const dps = state.rpm * 720 / 60000;
  anim.angle = wrap(anim.angle + dps * dt);
  cursorDeg.textContent = anim.angle.toFixed(0);

  // mover linha do cursor sem redesenhar tudo: atualiza atributo x do elemento existente
  const cursor = document.getElementById('cursorLine');
  if (cursor){
    cursor.setAttribute('x1', scaleX(anim.angle));
    cursor.setAttribute('x2', scaleX(anim.angle));
  }else{
    render(); // primeira vez cria o cursor
  }

  anim.raf = requestAnimationFrame(loop);
}

const toggleBtn = document.getElementById('toggle');
toggleBtn.addEventListener('click', ()=>{
  state.running = !state.running;
  toggleBtn.textContent = state.running ? '❚❚ Pausar' : '▶︎ Reproduzir';
  if (state.running){ anim.lastT = 0; anim.raf = requestAnimationFrame(loop); }
});

// iniciar
syncLabels();
render();
</script>
</body>
</html>
